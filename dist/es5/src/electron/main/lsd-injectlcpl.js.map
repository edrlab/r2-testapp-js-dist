{"version":3,"file":"lsd-injectlcpl.js","sourceRoot":"","sources":["../../../../../src/electron/main/lsd-injectlcpl.ts"],"names":[],"mappings":";;;AAAA,uBAAyB;AAGzB,kDAAiD;AACjD,sDAA2D;AAC3D,8BAAgC;AAChC,mCAAyC;AAEzC,IAAM,KAAK,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAE7C,4BACI,OAAe,EACf,WAAwB,EACxB,eAAuB;;;;;YAEjB,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAC5C,KAAK,CAAC,QAAQ,CAAC,CAAC;YAEV,YAAY,GAAG,uBAAuB,CAAC;YAG7C,IAAI,CAAC;gBACD,IAAI,GAAG,cAAM,CAAC,WAAW,CAAM,QAAQ,EAAE,SAAG,CAAC,CAAC;YAClD,CAAC;YAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACb,MAAM,KAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC;YACjC,CAAC;YACD,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC;YAC5B,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;YAC1B,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC;YAIvB,WAAO,IAAI,OAAO,CAAM,UAAO,OAAO,EAAE,MAAM;;;wBACpC,kBAAkB,GAAG,eAAe,GAAG,MAAM,CAAC;wBACpD,+BAAiB,CAAC,eAAe,EAAE,kBAAkB,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,YAAY,EAC7F,UAAC,GAAG;4BACA,MAAM,CAAC,GAAG,CAAC,CAAC;wBAChB,CAAC,EACD;4BACI,KAAK,CAAC,6BAA6B,CAAC,CAAC;4BAErC,UAAU,CAAC;gCACP,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;gCAC/B,UAAU,CAAC;oCACP,EAAE,CAAC,UAAU,CAAC,kBAAkB,EAAE,eAAe,CAAC,CAAC;oCACnD,OAAO,CAAC,eAAe,CAAC,CAAC;gCAC7B,CAAC,EAAE,GAAG,CAAC,CAAC;4BACZ,CAAC,EAAE,GAAG,CAAC,CAAC;wBACZ,CAAC,CAAC,CAAC;;;qBACV,CAAC,EAAC;;;CACN;AAzCD,gDAyCC","sourcesContent":["import * as fs from \"fs\";\n\nimport { Publication } from \"@models/publication\";\nimport { LCP } from \"@r2-lcp-js/parser/epub/lcp\";\nimport { injectBufferInZip } from \"@utils/zip/zipInjector\";\nimport * as debug_ from \"debug\";\nimport { JSON as TAJSON } from \"ta-json\";\n\nconst debug = debug_(\"r2:electron:main:lsd\");\n\nexport async function lsdLcpUpdateInject(\n    lcplStr: string,\n    publication: Publication,\n    publicationPath: string): Promise<string> {\n\n    const lcplJson = global.JSON.parse(lcplStr);\n    debug(lcplJson);\n\n    const zipEntryPath = \"META-INF/license.lcpl\";\n\n    let lcpl: LCP;\n    try {\n        lcpl = TAJSON.deserialize<LCP>(lcplJson, LCP);\n    } catch (erorz) {\n        return Promise.reject(erorz);\n    }\n    lcpl.ZipPath = zipEntryPath;\n    lcpl.JsonSource = lcplStr;\n    lcpl.init();\n    publication.LCP = lcpl;\n    // publication.AddLink(\"application/vnd.readium.lcp.license-1.0+json\", [\"license\"],\n    //     lcpl.ZipPath, false);\n\n    return new Promise<any>(async (resolve, reject) => {\n        const newPublicationPath = publicationPath + \".new\";\n        injectBufferInZip(publicationPath, newPublicationPath, Buffer.from(lcplStr, \"utf8\"), zipEntryPath,\n            (err) => {\n                reject(err);\n            },\n            () => {\n                debug(\"EPUB license.lcpl injected.\");\n\n                setTimeout(() => {\n                    fs.unlinkSync(publicationPath);\n                    setTimeout(() => {\n                        fs.renameSync(newPublicationPath, publicationPath);\n                        resolve(publicationPath);\n                    }, 500);\n                }, 500);\n            });\n    });\n}\n"]}